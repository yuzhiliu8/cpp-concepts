# Type Conversion, Aliases, Deduction

Implicit Type Conversion Happens during:
- initialization and assignment
- returning
- binary operators with different types
- non bool if statement
- passing in as parameter


Numeric Promotions
- Always safe. Equal value, meaning promoting numeric types keeps the same value, but just in a differen type
- turning narrow width numeric type to larger width type
- float --> double (floating pt promotion)
- short --> int (integral promotion)

in general, all bools, chars, shorts can get promoted to int
good strat is to take int as paramter --> implicitly converted

Numeric Conversions
- Any numeric to numeric type conversion that isn't a promotion
- wider to narrow numeric type
- float to int, float to double, int to float, to bool, etc.


Reinterpretive conversion:
- unsafe conversion, converted value may be different from source value, no "data" is lost
- -5 int converted to uint loses -5 value ('reinterpreted')
- converted to reinterpreted value and then converting back produces same original value 

Lossy conversion:
- unsafe, results in data loss
- double to float, float to int --> lose precision
- most of the time cannot convert back and preserve original value

Narrowing conversion:
- dest. type possibly can't hold source type (similar to lossy)
- generally unsafe, try using explicit narrowing cast vs implicit narrow cast

Arithmetic Conversions:
- Most standard non overloaded operators require both arguments to be the same type --> uses implicit conversion to achieve that 
- integrals will match the other FP
- lower rank type converted to higher rank type
    - long double (highest rank) double
    - float
    - long long
    - long
    - int (lowest rank)
- obscure rules for unsigned, signed stuff


Casting
- static_cast: compile-time type conversions
- dynamic_cast: runtime conversions between pointers/references in class inheritance hierarchy
- const_cast: add/remove constness
- reinterpret_cast: reinterpret bit-level as if it were another type
- C-style: combination of the above 4

Avoid C style cast, bc not explicit which cast type(s) is being used
Prefer static cast over direct list initialization of temp obj

Typedefs, Type Aliases
- Type alias follows the same scoping rules applied to variables. 
- Use type aliases over typedef
- Best used to simplify typing out long complex types and give them meaning
    - `std::vector<std::pair<std::string, int>>` vs `NameToIdList`

Auto
- Compiler does type deduction from the initalizer value
- drops the const from the initializer type usually