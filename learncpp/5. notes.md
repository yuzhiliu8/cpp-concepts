# Ch.5 - Constants, Strings

### Constants
two types:
 - named constants (variables)
 - literal constants

### Const variables
- use `const` keyword before
- must be initialized, assignment later not allowed
- can use `const` as a function parameter. 

`void function(const int x);`
- When passing value `function(val)`, x is initialized: `const int x = val`. 
- This is not useful for pass by value, since we dont care if we change the value of a copy --> it will get destroyed once the function goes out of scope
- Dont use `const` with **return by value** types for functions. Usually impedes compiler optimizations(move semantics), useless for primitives/basic types, little use cases for complex types

### String Literals
- Standard double quotes are C style string literals
- of type `const char[]`, which decays into `const char*`
- All C style strings end in a null terminator character
- All C style string literals are created(in the executable) from program start to finish, cannot get destroyed. (only pointers to them can get destroyed)
- `std::string` and `std::string_view` literals create temporary objects that get destroyed at the end of their expression. The objects get destroyed, not the actual underlying literal itself

### Number systems
- prefix 0 for octal literal
- prefix `0x` for hexa literal
- `0b` prefix for binary literal
- hex usually used to represent raw data or memory addresses or raw data in memory. 64 bit systems have memory addresses of 64 bits --> 16 hex digits

### Const, Constexpr
- for initializing `const` and `constexpr` variables, the initialization value must be a constant expression --> allows for compile time optimization/calculations
- only const integral types with a const expr initalizer value are compile time constants
- `const`: use when want read only after initialization
    - compiler may or may not know final value at compile time
- `constexpr`: use when you need compile-time constants for templates, array sizes, or constant expressions
    - must be evaluable at compile time
    - implies const
    - usable in any other constexpr

- any const variable whos value can be determined at compile time should be constexpr
- any other const whose values are determined at runtime should be const
- Some types not compatible with constexpr --> just use const

#### Function parameter const
- const parameter are runtime consts
- cannot use constexpr as function parameters

### `std::string`
- basically a wrapper for internally kept c style string (dynamic memory alloc, char pointer) --> why std string is usually slower
- allows for in place modification, reassignment (different lengths too)
- `.length() - member function`
- initializing std::string is usually expensive, because a copy of the string (literal or var) used to create it is stored
- **Dont pass in std::string by value into functions/constructors, since it creates a copy**
- when returning by value, usually return value is copied back to the caller
- however, returning std::strings is generally okay due to it supporting move semantics (allows return by value without making a copy)
- another option is to return by const reference `const std::string&`

local std::string variable:
```cpp
std::string make_string();

std::string func(){
    std::string x { "hello" };
    return x; //returning lcoal std::string variable
    return make_string(); //returning a string that was returned by value
    return std::string("hello"); //returning temp string obj
    return "hello"; //c string literal gets implicitly casted to temp std::string obj
}
```
#### std::string literal
- `using namespace std::string_literals`
- `"my string"s` --> `std::string { "my string" }` constructs temp obj in place

### std::string_view
- provides read-only access to a C style string literal
- no copies, expensive copy, since it just contains a pointer to the c style string literal

### std::string_view
- provides read-only access to a C style string literal
- no expensive copy when passing by value, since it just contains a pointer to the c style string literal. --> very cheap copy as opposed to copying the entire data buffer
- can be initialized with string literal, std::string, or another std::string_view

### Owners and viewers
- viewing: 
    - inexpensive, and you have no responsibility over objects that you view, as they are owned by something else
    - you also have no control over those objets
- ownership:
    - can be expensive
    - responsible for acquiring, maintaining, and disposing of resources well

std::string is an owner because it copies the initialization value into its own internal memory. It no longer needs the initial value/object after initialization. However, this ownership is expensive, since you need to copy the data.

- if you pass in object not by value (ref, pointer) for initialiation, after initialization (creating a viewer)
    - if object was temporary --> destroyed, can lead to UB if initialized obj still relies on that temp obj
    - initializer was variable --> caller still has control of that variable. Modifying or destroying it will change the behavior of using the viewer

consider this case:
```cpp
void printString(std::string str) { }

int main()
{
    std::string s{ "Hello, world!" };
    printString(s);
    return 0;
}
```
- can we just use `s` DIRECTLY in `printString` to avoid making an expensive copy?
    - can `s` be destroyed while printString is running?
    - can `s` be modified while printString is running?
    - will printString modify `s` in ways that the caller isn't expecting?

```cpp
std::string getName();

int main(){
    std::string_view sv{ getName() };
}
```
- the following is UB because sv points to the temp obj that getName returns. This temp obj is destroyed immediately after the expression --> dangling view
- We should instead store/copy 

```cpp
std::string_view x { std::string("hello") }; // temp std::string literal
```
 - this is UB, since the temp obj copies in the C string literal data into a new string obj internal data buffer
 - new string obj internal data buffer pointer copied over to x
 - temp string obj destroyed, --> x now dangling

 - modifying a string can also cause a string_view to become dangling
 - if reassigning, this can making string reallocate memory, and the buffer can be in a different memory location, and the string_view wont be updated and could be pointing to an invalid object

- `string_view` can beat `const std::string&` sometimes, if a C style string literal is passed in. 
    - `string_view` will have a pointer directly to the C string
    - `const std::string&` will first create a temp string object and reference that