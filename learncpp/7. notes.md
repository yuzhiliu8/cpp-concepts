# Ch.7 learncpp - scope, linkage, duration, lifetime
- scope: where a variable is accessible in code
- duration: how a obj is created or destroyed
- lifetime: time between initialization/creation and destruction
- local variables have block scope and automatic duration (created at definition, destroyed at end of scope)

### Global variables
- can define variables in global scope, outside of funcs
- global vars have static duration: created before main runs, destroyed after main finishes --> static variables

### Variable Shadowing
- an identifier with the same name as another one in a larger scope will "mask" it
- nested blocks, global var shadowing

### Internal linkage
- Identifier w/ internal linkage can only be seen and used within one translation unit (one source file, after preprocessor directives)
- Having the same identifier w/ internal linkage --> doesn't violate One Definition Rule

- `const`, `constexpr` have internal linkage
- `static` to make identifier internal linkage (global scope or namespace scope)
    - applies to variables, functions (they have default external linkage)
- invisible to linker

### External Linkage
- Visible to linker
    - Connect a definition from on translation unit to the identifier used is another translation unit, (Must follow ODR)
    - Deduplicate inline definitions 
- functions have external linkage by default --> why forward declarations work, and why multiple definitions break ODR
- `extern` to make global scope variables have external linkage
    - don't need to use for non const globals

Fwd declaration of external global variables in another translation unit:
```cpp
extern int g_x; //g_x is defined somewhere else as int g_x{ value };
extern const int g_y; //defined in diff TU as extern const int g_y { value };
```

### Non const globals
- Non const globals make your program less modular and less flexible
- generally avoid non const globals
- the order in which static variables are initialized across different translation units is not well defined / consistent
- don't initialize globals with globals from other translation units
- avoid dynamic global initialization


### Inline
- external linkage by default
- previously used to suggest inline expansion for functions in order to reduce call overhead (modern compilers take care of this)
- Now used to say that multiple definitions are allowed
    - An inline function is allowed to be defined in multiple different translation units
    - still max of ONE definitions, duplicates in same TU --> compilation error
    - If the inline function is used, the compiler must see see whole function definition in the same TU
    - Every definition of an inline function across different TUs must be identical
    - the linker will consolidate every inline definition into one 
    - define inline functions and variables in header files

### Inline shared global variables (in headers)
- can be used in constant expressions in any TU that includes them --> compiler optimization
- Only one copy of each variable bc of inline
- changing header values means recompiling every source file that includes the header (can be slower, but tradeoff for maintainability)
    - you can bypass this by defining it in one source file and "importing" via extern, but this prevents constexpr optimizations

### Static local variables
- makes local variable have static duration instead of automatic "block" duration
- going out of scope doesn't kill the variable
- so local variable data persists, but you can still restrict accessibility/scope to local scope
    - example of scope and lifetime being different
- used when you need persisting information across function calls (local to function)
- since its only initialized once, can avoid expensive initializations