# Function Overloading
- must be overload differentiated and also resolve correctly

Differentiated by:
- num parameters
- type of parameters
- NOT return type
- const


## Argument Matching Sequence:
- (1): checks for function def with EXACT MATCH param types
- (2): it will apply trivial conversions to arguments to get them to match
    - lvalue to rvalue conversion
    - qualification (non const to const)
    - non-reference to reference (temporary double literal can get binded const double reference)
    - Trivial conversion matches are considered EXACT matches. The following are considered exact matches (for the same types), but different functions
    ```cpp
    void foo(int)
    void foo(const int&)
    ```
    - for lvalue argument: better to binding to reference
    - for rvalue argument: better to pass by value
    - compilers should warn/fail for ambiguous matching
- (3): Find matching arguments by using numeric promotion
    - char -> int
    - float -> double
- (4): Find matching using numeric conversion
    - if no int overload, then char -> double
- (5): Tries to find a match thru user defined conversions
    -   overloading operator (`operator int()`)
    - constructor of a class is also a user defined conversion from other types to that class type --> compiler can use this
- (6): looks for ellipsis
- (7): compiler error


Can make functions uncallable, via `= delete`
- if we want only `foo(int)` to be callable, but not allow overload resolution of `foo(true)` or `foo('c')` to work, we do `void foo(bool) = delete;`

All delete non matching type overloads:
```cpp
void printInt(int x);
template <typename T>
void printInt(T x) = delete;
```

Default arguments:
- best practice: declare default args in the function definition during the forward definition (including header files), but don't include them in the implementation