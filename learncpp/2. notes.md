# Ch.2 learncpp

### Functions
In a return statement: (non-void, primitive return type)
- return expression evaluated to produce a result
- the value is copied back (return value) to the caller
- function exits

Copying back a return value is called `return by value` 

You cannot call `main` yourself in C++, for example in another function

#### Parameters
- Function parameters are created as variables, and then the value of each argument is copied into the corresponding parameter with copy initialization
- **value parameters** are **passed by value** and so the parameters are copies of the values passed into the function
- modifying this parameter will not modify the caller variable.

**Unnamed Parameters**: 
```cpp
void doSomething(int){ // ok: unnamed parameter will not generate warning
}
```

### Local Scope
- Variables defined in a function body are local variables, as opposed to global variables 
- Function parameters are also considered local variables in the scope of the function body
- Local variables are destroyed in the reverse order in which they are created when they go out of scope (reach the end of the curly braces). This occurs at runtime and after destruction, the memory they used up is deallocated
- lifetime is a runtime property, and scope is a compile time property
```cpp
int add(int x, int y) //x, y created and initialized
{
    int z{ x + y }; //z created and initialized

    return z;
} // z, y, and x destroyed here
```
- use of object/variable after destruction results in undefined behavior

- Temporary Object: unnamed object that holds a value, only exist for a short period. Generated by compilers when needed.
    - returning by value returns a temp object that holds the return value to the caller. Modern C++ compilers can optimize this out tho
    - have no scope and destroyed at the end of the expression

### Forward Declaration
- Declare a function before actually defining it so the compiler knows it the identifier exists
- Useful for forward declaring functions and then using them later on
- If declared but not defined, and your code uses the function --> linker error

#### One Definition Rule
- In a file, each function/variable can only have one definition in the given scope
- In a program, each func/var can only have one def in the scope
- Types, template and inlines are allowed to have multiple definitions in diff files, as long as they are identical

### Multi File Programs
`main.cpp`:
```cpp
#include <iostream>

//int add(int x, int y);  //forward declaration

int main()
{
    std::cout << "The sum of 3 and 4 is: " << add(3, 4) << '\n'; // compile error
    return 0;
}
```
`add.cpp`
```cpp
int add(int x, int y)
{
    return x + y;
}
```
- The compiler compiles each file individually (when turning to object files), and does not know the contents of other files, even if it compiled those other files before
- This allows for compilation of files in any order
- When we change a src file, we only need to recompile that src file
- Reduces naming conflicts between files

Here, we can either define the add function before main in `main.cpp` or add a forward declaration at the top of `main.cpp`. Since we want add in a separate file, we do a forward declaration.

- Compiler compiles --> linking takes care of resolving the declaration
- This is why we do `include` statements. Bc we import function/identifier declarations and tell our program these are defined elsewhere. After compilation, the linker resolves all of these things, like `std::cout`

### Naming Collisions
- If the same identifier is defined at least twice in the same scope (colliding identifiers) in the same file --> compiler error
- If colliding identifiers in diff files --> linker error

#### Namespace scope
- namespaces lets you define/declare things within it to disambiguate/clarify from other namespaces
- within a namespace, everything has to be unique tho
- Anything that is not defined in a class, function, or namespace is implicity in the **global namespace**
- `std` namespace hosts all of the C++ standard library functions/identifiers. Prevents collisions in global namespace

### Preprocessor
- The compiler first preprocesses before actually compiling
- Strips out comments, adds newline at end, and processes preprocessor directives such as `#include`
- After preprocessing --> translation unit

`#include`:
- replaces the line `#include <whatever>` with the contents from that file (usually header file)

Macro Defines
- There are object-like and function-like macros
- Define an object-like macro:
```cpp
#define IDENTIFIER
#define IDENTIFIER substitution_text
```
- substitution text creates a sort of variable that preprocessors replace with the substitution text. Not necessary in modern C++
- w/o substitution_text: most further occurrences of the identifier are replaced with nothing

Condition Compilation:
- The #ifdef preprocessor directive allows the preprocessor to check whether an identifier has been previously defined via #define. If so, the code between the #ifdef and matching #endif is compiled. If not, the code is ignored.

- A define macro only works from the definition to the end of the file. It won't do anything in other files, unless that line is #included into that other file --> useful for header guards

### Header Files

Best practices:
- The paired header file for this code file (e.g. add.cpp should #include "add.h")
- Other headers from the same project (e.g. #include "mymath.h")
- 3rd party library headers (e.g. #include <boost/tuple/tuple.hpp>)
- Standard library headers (e.g. #include <iostream>)

The headers for each grouping should be sorted alphabetically (unless the documentation for a 3rd party library instructs you to do otherwise).
- Always include header guards 
- Do not define variables and functions in header files without inline
- Give a header file the same name as the source file it’s associated with (e.g. grades.h is paired with grades.cpp).
- Each header file should have a specific job, and be as independent as possible. For example, you might put all your declarations related to functionality A in A.h and all your declarations related to functionality B in B.h. That way if you only care about A later, you can just include A.h and not get any of the stuff related to B.
- Be mindful of which headers you need to explicitly include for the functionality that you are using in your code files, to avoid inadvertent transitive includes.
- A header file should #include any other headers containing functionality it needs. Such a header should compile successfully when #included into a .cpp file by itself.
- Only #include what you need (don’t include everything just because you can).
- Do not #include .cpp files.
- Prefer putting documentation on what something does or how to use it in the header. It’s more likely to be seen there. Documentation describing how something works should remain in the source files.

### Header Guards
It is common that a definition in a header gets included more than once. If you include a header that includes other headers, this will likely happen
- Can be shown with function definitions in headers (which is bad pratice, but for educational purposes)

`add.h`:
```cpp
int f(int x){
    return x;
}
```

`other.h`:
```cpp
#include "add.h"
```

`main.cpp`:
```cpp
#include "add.h"
#include "other.h"
```
- This will result in two identical definitions of `f()` --> compilation error, since `add.h` was included twice

Header Guards:
```cpp
#ifndef UNIQUE_NAME
#define UNIQUE_NAME

// your declarations (and certain types of definitions) here

#endif //#ifndef block
```
- if the macro `UNIQUE_NAME` hasn't been defined in this translation unit/file, this is the first time it is being included, and we will include/compile with all declarations until the endif block.
- this also means that `UNIQUE_NAME` was never defined, since it is the first time we have seen it in the translation unit. We define it with a macro w/o text_substitution
- If it is seen again, the preprocessor sees that `UNIQUE_NAME` has been defined already, and then it skips the declarations in the `#ifndef ... #endif` block

IMPORTANT:
- Header guards only prevent a header from being included in a source file/translation unit more than once, it is still possible, and common for a header file to be included once in multiple source files.
- If a function `f()` is defined in both `main.cpp` and `test.cpp` (due to including a header that defined it) in the global namespace --> linker error
- solution is to just have only function declarations in header files --> keep definition in cpp files (at least without inline)

can also use a single liner: `#pragma once` that lets compiler handle header guards. 
