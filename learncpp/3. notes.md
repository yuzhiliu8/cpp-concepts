# learncpp Ch.3

### Fundamental Data Types:


- int, bool, float/double, char, void (no type)
- integral types: short, int, long, long long
- void is used when function doesn't return a value, and for void pointers (later)

### Object Sizes
- Memory is organized into byte-sized units, each byte has its own unique address
- `sizeof` operator: outputs size of type or variable/object in bytes
- does not work on dynamically allocated memory at runtime, only gets memory/sizes at compile time

### Integer (Signed)
- Modern ints 4 bytes
- (-) ~2 billion to (+) ~2 billion
- Use up 1 bit to represent the sign (pos or neg)

**Integer Overflow**
- Assigning a result that is not in the expected/defined range of a type results in UB
- 8 bit int has -128 to 127 range. assigning 140 --> overflow

### Unsigned int
- use `unsigned` keyword before an integral type
- dont use beginning bit to represent sign, can store bigger pos numbers compared to signed ints, but can still store the same number of unique values

For overflow, unsigned ints use modulo wrapping
- for int from 0 to 255 range, we mod (255 + 1), so assigning 256 would result in 0
- try not to mix signed and unsigned ints. Trying to do operations with them usually makes signed ints get converted to unsigned, which can cause weird behavior

### Fixed-Width Integers
- C++ Guarantees that a standard `int` has a min of 2 bytes
- For modern archs, `int` is 4 bytes or 32-bit
- these type sizes aren't standardized, and compilers can choose based on the architecture they are running on --> bad for portability

Fixed-width: Same size no matter the architecture they are running on
`std::int8_t`: 1 byte, signed
`std::uint8_t`: 1 byte, unsigned
... 16, 32, 64
- These are really just aliases for existing types. `std::int32_t` will be an alias for whatever type on that architecture is the same size as 4 bytes / 32 bits
- This is why `std::int8_t` or unsigned version is treated as a signed/unsigned char --> since only available type that is 1 byte

#### `std::size_t`
- sizeof returns an integer value of type `std::size_t`, which is any unsigned integral type. The compiler decides (unsigned int, long, etc). Alias type (typedef)
- size_t puts a constraint on the maximum size of an object

### Floating point
- floating point literals will default to type double. Appendgin `f` to the end will make them a `float` type literal
- It is best that literals match the type of var that they are being assigned to --> or else unnecessary type conversion will occur and can lead to loss of precision

- floating pt numbers are stored in scientific notation (binary format)
- the range of floats depends on how many bits are dedicated to the exponent
- the precision depends on how many bits are dedicated to the decimal/fractional component of the number (significant figures)
- `std::setprecision` and `std::setw` to print decimal precision and format text

- Rounding errors occur because we have limited memory to represent infinite real numbers --> close approximations
- Bc rounding err, generally bad to directly compare floats

### Bool
- outputted as 0 or 1 (technically integral type)
- initialization allows for 0 or 1
- copy assignment allows implicit type conversion (0 --> false, any other int --> true) ONLY after initialization

### Char 
- Also integral type since integer value is used to represent it
- ASCII Character
- can initialize with charater literal or integer

### Type Conversions
- When program/compiler does it automatically: **implicit type conversion**
- Think of an implicit type conversion as using/returning a temporary object with the converted type
- Some implicit type conv is good, but not when you lose information, such as in double --> int conversion
- stay away from C-style casting, such as `(int) 5.5`
    - It hides what kind of cast is being used. --> will automatically try static, dynamic, reinterpret, etc.
    - Will compile even if it leads to UB
    - general rule, DONT use
